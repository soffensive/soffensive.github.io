<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Web Application Security - Tag - soffensive blog</title><link>https://www.soffensive.com/tags/web-application-security/</link><description>Web Application Security - Tag - soffensive blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 18 May 2019 05:35:00 -0700</lastBuildDate><atom:link href="https://www.soffensive.com/tags/web-application-security/" rel="self" type="application/rss+xml"/><item><title>XXE with .NET in 2019</title><link>https://www.soffensive.com/posts/web-app-sec/2019-05-18-xxe-with-net-in-2019/</link><pubDate>Sat, 18 May 2019 05:35:00 -0700</pubDate><author>Author</author><guid>https://www.soffensive.com/posts/web-app-sec/2019-05-18-xxe-with-net-in-2019/</guid><description>After the seminal blog post by James Jardine in 2016 on XXE exploitation in .NET applications back in 2016, Microsoft seems to have implemented some additional changes regarding the default behavior of XML parsers.
We work through the different XML methods provided and their corresponding vulnerable configurations. For all experiments, .NET framework 4.6 was chosen.
TL;DR In order to create an XXE vulnerability for applications using .NET framework 4.6+, you have to instantiate a vulnerable XmlResolver beforehand.</description></item><item><title>Exploiting Blind File Reads / Path Traversal Vulnerabilities on Microsoft Windows Operating Systems</title><link>https://www.soffensive.com/posts/web-app-sec/2018-06-19-exploiting-blind-file-reads-path-traversal-vulnerabilities-on-microsoft-windows-operating-systems/</link><pubDate>Tue, 19 Jun 2018 01:31:00 -0700</pubDate><author>Author</author><guid>https://www.soffensive.com/posts/web-app-sec/2018-06-19-exploiting-blind-file-reads-path-traversal-vulnerabilities-on-microsoft-windows-operating-systems/</guid><description>In a recent engagement I was confronted with a blind path traversal vulnerability on a server running with the Microsoft Windows operating system. That is, it was not possible to display folder contents but the complete file name and path had to be guessed. Due to the lack of a comprehensive website I was forced to gather information from various different sources.
In this blog post, I want to summarize my findings and focus on the exploitation ofÂ this kind of vulnerability.</description></item><item><title>Cross-Site Scripting Attacks with adverse Conditions: Upper-Case XSS</title><link>https://www.soffensive.com/posts/web-app-sec/2017-04-05-cross-site-scripting-attacks-with-adverse-conditions-upper-case-xss/</link><pubDate>Wed, 05 Apr 2017 04:03:00 -0700</pubDate><author>Author</author><guid>https://www.soffensive.com/posts/web-app-sec/2017-04-05-cross-site-scripting-attacks-with-adverse-conditions-upper-case-xss/</guid><description><![CDATA[Several times I have encountered web applications that convert user-provided input to capital letters. For example, the application may behave as follows:

The injected JavaScript code (after escaping from the quotes, of course) will not be executed in the browser. Why is this the case? Remember that the HTML tag names themselves, including &lt;SCRIPT&gt; are not case-sensitive, whereas the contents inside them are in fact case-sensitive.
You can circumvent this limitation by using a different injection technique that involves, for instance, &lt;img&gt; tags and converting the JavaScript code into HTML entities.]]></description></item></channel></rss>