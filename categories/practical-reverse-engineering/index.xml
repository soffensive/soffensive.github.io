<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>practical reverse engineering - Category - soffensive blog</title>
        <link>http://localhost:1313/categories/practical-reverse-engineering/</link>
        <description>practical reverse engineering - Category - soffensive blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 07 Dec 2017 10:29:00 -0800</lastBuildDate><atom:link href="http://localhost:1313/categories/practical-reverse-engineering/" rel="self" type="application/rss+xml" /><item>
    <title>Practical Reverse Engineering Exercise Solutions: Page 79 / Exercise 11</title>
    <link>http://localhost:1313/posts/practical-reverse-engineering/2017-12-07-practical-reverse-engineering-exercise-solutions-page-79-exercise-11/</link>
    <pubDate>Thu, 07 Dec 2017 10:29:00 -0800</pubDate>
    <author>Author</author>
    <guid>http://localhost:1313/posts/practical-reverse-engineering/2017-12-07-practical-reverse-engineering-exercise-solutions-page-79-exercise-11/</guid>
    <description><![CDATA[Exercise 11 on page 79 of the book Practical Reverse Engineering specifies the following ARM disassembly of a function called mystery11 - the last exercise of the ARM chapter:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  01: 010185B0 mystery11 02: 010185B0 2D E9 F8 4F PUSH.]]></description>
</item><item>
    <title>Practical Reverse Engineering Exercise Solutions: Page 79 / Exercise 10</title>
    <link>http://localhost:1313/posts/practical-reverse-engineering/2017-12-06-practical-reverse-engineering-exercise-solutions-page-79-exercise-10/</link>
    <pubDate>Wed, 06 Dec 2017 06:19:00 -0800</pubDate>
    <author>Author</author>
    <guid>http://localhost:1313/posts/practical-reverse-engineering/2017-12-06-practical-reverse-engineering-exercise-solutions-page-79-exercise-10/</guid>
    <description><![CDATA[Exercise 10 on page 79 of the book Practical Reverse Engineering specifies the following ARM disassembly of a function called mystery10:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  01: mystery10 02: 2D E9 70 48 PUSH.]]></description>
</item><item>
    <title>Practical Reverse Engineering Exercise Solutions: Page 79 / Exercise 9</title>
    <link>http://localhost:1313/posts/practical-reverse-engineering/2017-12-05-practical-reverse-engineering-exercise-solutions-page-79-exercise-9/</link>
    <pubDate>Tue, 05 Dec 2017 06:47:00 -0800</pubDate>
    <author>Author</author>
    <guid>http://localhost:1313/posts/practical-reverse-engineering/2017-12-05-practical-reverse-engineering-exercise-solutions-page-79-exercise-9/</guid>
    <description><![CDATA[Exercise 9 on page 79 of the book Practical Reverse Engineering specifies the following ARM disassembly of a function called mystery9:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  01: mystery9 02: 2D E9 30 48 PUSH.W {R4,R5,R11,LR} 03: 0D F2 08 0B ADDW R11, SP, #8 04: 09 4D LDR R5, =byteArray 05: 06 E0 B loc_100E312 06: loc_100E304 07: 0B 78 LDRB R3, [R1] 08: 5A 5D LDRB R2, [R3,R5] 09: 63 5D LDRB R3, [R4,R5] 10: 93 42 CMP R3, R2 11: 04 D1 BNE loc_100E318 12: 01 30 ADDS R0, #1 13: 01 31 ADDS R1, #1 14: loc_100E312 15: 04 78 LDRB R4, [R0] 16: 00 2C CMP R4, #0 17: F5 D1 BNE loc_100E304 18: loc_100E318 19: 0B 78 LDRB R3, [R1] 20: 5A 5D LDRB R2, [R3,R5] 21: 03 78 LDRB R3, [R0] 22: 5B 5D LDRB R3, [R3,R5] 23: 98 1A SUBS R0, R3, R2 24: BD E8 30 88 POP.]]></description>
</item><item>
    <title>Practical Reverse Engineering Exercise Solutions: Page 79 / Exercise 8</title>
    <link>http://localhost:1313/posts/practical-reverse-engineering/2017-12-05-practical-reverse-engineering-exercise-solutions-page-79-exercise-8/</link>
    <pubDate>Tue, 05 Dec 2017 02:30:00 -0800</pubDate>
    <author>Author</author>
    <guid>http://localhost:1313/posts/practical-reverse-engineering/2017-12-05-practical-reverse-engineering-exercise-solutions-page-79-exercise-8/</guid>
    <description><![CDATA[Exercise 8 on page 79 of the book Practical Reverse Engineering specifies the following ARM disassembly of a function called mystery8:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  01: mystery8 02: 2D E9 78 48 PUSH.W {R3–R6,R11,LR} 03: 0D F2 10 0B ADDW R11, SP, #0x10 04: 0C 4E LDR R6, =byteArray 05: 09 E0 B loc_100E34C 06: loc_100E338 07: 05 78 LDRB R5, [R0] 08: 01 3A SUBS R2, #1 09: 4D B1 CBZ R5, loc_100E352 10: 0B 78 LDRB R3, [R1] 11: 9C 5D LDRB R4, [R3,R6] 12: AB 5D LDRB R3, [R5,R6] 13: A3 42 CMP R3, R4 14: 04 D1 BNE loc_100E352 15: 01 30 ADDS R0, #1 16: 01 31 ADDS R1, #1 17: loc_100E34C 18: 00 2A CMP R2, #0 19: F3 DC BGT loc_100E338 20: 01 3A SUBS R2, #1 21: loc_100E352 22: 00 2A CMP R2, #0 23: 01 DA BGE loc_100E35A 24: 00 20 MOVS R0, #0 25: 04 E0 B locret_100E364 26: loc_100E35A 27: 0B 78 LDRB R3, [R1] 28: 9A 5D LDRB R2, [R3,R6] 29: 03 78 LDRB R3, [R0] 30: 9B 5D LDRB R3, [R3,R6] 31: 98 1A SUBS R0, R3, R2 32: locret_100E364 33: BD E8 78 88 POP.]]></description>
</item><item>
    <title>Practical Reverse Engineering Exercise Solutions: Page 79 / Exercise 7</title>
    <link>http://localhost:1313/posts/practical-reverse-engineering/2017-12-04-practical-reverse-engineering-exercise-solutions-page-79-exercise-7/</link>
    <pubDate>Mon, 04 Dec 2017 06:14:00 -0800</pubDate>
    <author>Author</author>
    <guid>http://localhost:1313/posts/practical-reverse-engineering/2017-12-04-practical-reverse-engineering-exercise-solutions-page-79-exercise-7/</guid>
    <description><![CDATA[Exercise 7 on page 79 of the book Practical Reverse Engineering specifies the following ARM disassembly of a function called mystery7:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  01: mystery7 02: 02 46 MOV R2, R0 03: 08 B9 CBNZ R0, loc_100E1D8 04: 00 20 MOVS R0, #0 05: 70 47 BX LR 06: loc_100E1D8 07: 90 F9 00 30 LDRSB.]]></description>
</item><item>
    <title>Practical Reverse Engineering Exercise Solutions: Page 79 / Exercise 6</title>
    <link>http://localhost:1313/posts/practical-reverse-engineering/2017-12-04-practical-reverse-engineering-exercise-solutions-page-79-exercise-6/</link>
    <pubDate>Mon, 04 Dec 2017 03:17:00 -0800</pubDate>
    <author>Author</author>
    <guid>http://localhost:1313/posts/practical-reverse-engineering/2017-12-04-practical-reverse-engineering-exercise-solutions-page-79-exercise-6/</guid>
    <description><![CDATA[Exercise 6 on page 79 of the book Practical Reverse Engineering specifies the following ARM disassembly of a function called mystery6:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  01: mystery6 02: 2D E9 18 48 PUSH.W {R3,R4,R11,LR} 03: 0D F2 08 0B ADDW R11, SP, #8 04: 04 68 LDR R4, [R0] 05: 00 22 MOVS R2, #0 06: 00 2C CMP R4, #0 07: 06 DD BLE loc_103B3B6 08: loc_103B3A8 09: 50 F8 04 3F LDR.]]></description>
</item><item>
    <title>Practical Reverse Engineering Exercise Solutions: Page 79 / Exercise 5</title>
    <link>http://localhost:1313/posts/practical-reverse-engineering/2017-12-03-practical-reverse-engineering-exercise-solutions-page-79-exercise-5/</link>
    <pubDate>Sun, 03 Dec 2017 00:01:00 -0800</pubDate>
    <author>Author</author>
    <guid>http://localhost:1313/posts/practical-reverse-engineering/2017-12-03-practical-reverse-engineering-exercise-solutions-page-79-exercise-5/</guid>
    <description><![CDATA[Exercise 5 on page 79 of the book Practical Reverse Engineering specifies the following ARM disassembly of a function called mystery5:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  01: mystery5 02: 03 46 MOV R3, R0 03: 06 2B CMP R3, #6 04: 0D D0 BEQ loc_1032596 05: 07 2B CMP R3, #7 06: 09 D0 BEQ loc_1032592 07: 08 2B CMP R3, #8 08: 05 D0 BEQ loc_103258E 09: 09 2B CMP R3, #9 10: 01 D0 BEQ loc_103258A 11: 09 48 LDR R0, =aA ; &#34;A&#34; 12: 70 47 BX LR 13: loc_103258A 14: 07 48 LDR R0, =aB ; &#34;B&#34; 15: 70 47 BX LR 16: loc_103258E 17: 05 48 LDR R0, =ac ; &#34;C&#34; 18: 70 47 BX LR 19: loc_1032592 20: 03 48 LDR R0, =aD ; &#34;D&#34; 21: 70 47 BX LR 22: loc_1032596 23: 01 48 LDR R0, =aE ; &#34;E&#34; 24: 70 47 BX LR 25: ; End of function mystery5   All instructions have a width of 16 bits, so we are dealing with code in Thumb state.]]></description>
</item><item>
    <title>Practical Reverse Engineering Exercise Solutions: Page 79 / Exercise 4</title>
    <link>http://localhost:1313/posts/practical-reverse-engineering/2017-12-02-practical-reverse-engineering-exercise-solutions-page-79-exercise-4/</link>
    <pubDate>Sat, 02 Dec 2017 05:21:00 -0800</pubDate>
    <author>Author</author>
    <guid>http://localhost:1313/posts/practical-reverse-engineering/2017-12-02-practical-reverse-engineering-exercise-solutions-page-79-exercise-4/</guid>
    <description><![CDATA[Exercise 4 on page 79 of the book Practical Reverse Engineering specifies the following ARM disassembly of a function mystery4:
1 2 3 4 5 6 7 8  01: mystery4 02: 08 B9 CBNZ R0, loc_100C3DA 03: 00 20 MOVS R0, #0 04: 70 47 BX LR 05: loc_100C3DA 06: 50 F8 08 0C LDR.W R0, [R0,#–8] 07: 70 47 BX LR 08: ; End of function mystery4   The disassembly is in Thumb mode, as there are instructions having a width of 16 bits and some instructions specific to this mode (e.]]></description>
</item><item>
    <title>Practical Reverse Engineering Exercise Solutions: Page 79 / Exercise 3</title>
    <link>http://localhost:1313/posts/practical-reverse-engineering/2017-12-02-practical-reverse-engineering-exercise-solutions-page-79-exercise-3/</link>
    <pubDate>Sat, 02 Dec 2017 05:20:00 -0800</pubDate>
    <author>Author</author>
    <guid>http://localhost:1313/posts/practical-reverse-engineering/2017-12-02-practical-reverse-engineering-exercise-solutions-page-79-exercise-3/</guid>
    <description><![CDATA[Exercise 3 on page 79 of the book Practical Reverse Engineering specifies the following ARM disassembly of a function mystery3:
1 2 3 4 5 6 7 8  01: mystery3 02: 83 68 LDR R3, [R0,#8] 03: 0B 60 STR R3, [R1] 04: C3 68 LDR R3, [R0,#0xC] 05: 00 20 MOVS R0, #0 06: 4B 60 STR R3, [R1,#4] 07: 70 47 BX LR 08: ; End of function mystery3   It is provided in Thumb mode, as we can see from the instruction width, which is consistently 16 bits.]]></description>
</item><item>
    <title>Practical Reverse Engineering Exercise Solutions: Page 78 / Exercise 2</title>
    <link>http://localhost:1313/posts/practical-reverse-engineering/2017-12-02-practical-reverse-engineering-exercise-solutions-page-78-exercise-2/</link>
    <pubDate>Sat, 02 Dec 2017 04:40:00 -0800</pubDate>
    <author>Author</author>
    <guid>http://localhost:1313/posts/practical-reverse-engineering/2017-12-02-practical-reverse-engineering-exercise-solutions-page-78-exercise-2/</guid>
    <description><![CDATA[Exercise 2 of the ARM chapter has a rather short disassembly compared to the first exercise. Again, we are tasked with the decompilation of the provided function mystery2.
The disassembly is as follows:
1 2 3 4 5 6 7 8 9 10 11 12 13  01: mystery2 02: 28 B1 CBZ R0, loc_C672 03: 90 F8 63 00 LDRB.W R0, [R0,#0x63] 04: 00 38 SUBS R0, #0 05: 18 BF IT NE 06: 01 20 MOVNE R0, #1 07: 70 47 BX LR 08: loc_C672 09: 01 20 MOVS R0, #1 10: 70 47 BX LR 11: ; End of function mystery2   First of all, we notice that the function has been compiled in Thumb mode, as there are several instructions having a width of 16 bits, which is not possible in ARM mode.]]></description>
</item></channel>
</rss>
